package io.buildo.tapiro

import java.nio.file.Files

class TapiroSuite extends munit.FunSuite {

  check(
    "basic",
    Server.Http4s,
    """
      |/src/main/scala/schools/SchoolController.scala
      |package schools
      |
      |case class School(id: Long, name: String)
      |
      |sealed trait SchoolReadError
      |object SchoolReadError {
      |  case object NotFound extends SchoolReadError
      |}
      |
      |trait SchoolController[F[_], T] {
      |  @query
      |  def read(id: Long): F[Either[SchoolReadError, School]]
      |}
      |""".stripMargin,
    """
      |/src/main/scala/schools/endpoints/SchoolControllerEndpoints.scala
      |//----------------------------------------------------------
      |//  This code was generated by tapiro.
      |//  Changes to this file may cause incorrect behavior
      |//  and will be lost if the code is regenerated.
      |//----------------------------------------------------------
      |
      |package endpoints
      |import schools._
      |import sttp.tapir._
      |import sttp.tapir.Codec.{JsonCodec, PlainCodec}
      |import sttp.model.StatusCode
      |
      |trait SchoolControllerEndpoints[AuthToken] {
      |  val read: Endpoint[Long, SchoolReadError, School, Nothing]
      |}
      |
      |object SchoolControllerEndpoints {
      |
      |  def create[AuthToken](
      |      statusCodes: String => StatusCode = _ => StatusCode.UnprocessableEntity
      |  )(
      |      implicit codec0: JsonCodec[School],
      |      codec1: JsonCodec[SchoolReadError.NotFound.type],
      |      codec2: PlainCodec[Long]
      |  ) = new SchoolControllerEndpoints[AuthToken] {
      |    override val read: Endpoint[Long, SchoolReadError, School, Nothing] =
      |      endpoint.get
      |        .in("read")
      |        .in(query[Long]("id"))
      |        .errorOut(
      |          oneOf[SchoolReadError](
      |            statusMapping(
      |              statusCodes("NotFound"),
      |              jsonBody[SchoolReadError.NotFound.type]
      |            )
      |          )
      |        )
      |        .out(jsonBody[School])
      |  }
      |}
      |
      |/src/main/scala/schools/endpoints/SchoolControllerHttp4sEndpoints.scala
      |//----------------------------------------------------------
      |//  This code was generated by tapiro.
      |//  Changes to this file may cause incorrect behavior
      |//  and will be lost if the code is regenerated.
      |//----------------------------------------------------------
      |
      |package endpoints
      |import schools._
      |import cats.effect._
      |import cats.implicits._
      |import cats.data.NonEmptyList
      |import org.http4s._
      |import org.http4s.server.Router
      |import sttp.tapir.server.http4s._
      |import sttp.tapir.Codec.{JsonCodec, PlainCodec}
      |
      |object SchoolControllerHttp4sEndpoints {
      |
      |  def routes[F[_]: Sync, AuthToken](controller: SchoolController[F, AuthToken])(
      |      implicit codec0: JsonCodec[School],
      |      codec1: JsonCodec[SchoolReadError.NotFound.type],
      |      codec2: PlainCodec[Long],
      |      cs: ContextShift[F]
      |  ): HttpRoutes[F] = {
      |    val endpoints = SchoolControllerEndpoints.create[AuthToken]()
      |    val read = endpoints.read.toRoutes(controller.read)
      |    Router("/school" -> NonEmptyList(read, List()).reduceK)
      |  }
      |}
      |""".stripMargin,
  )

  def check(name: String, server: Server, layout: String, expectedLayout: String)(
    implicit loc: munit.Location,
  ): Unit =
    test(name) {
      val projectRoot = FileLayout.fromString(layout)
      val tapiro = new Util()
      tapiro.createFiles(
        List(projectRoot.toString),
        List(projectRoot.toString),
        projectRoot
          .resolve("src")
          .resolve("main")
          .resolve("scala")
          .resolve("schools")
          .resolve("endpoints")
          .toString,
        List("endpoints"),
        server,
      )

      FileLayout.mapFromString(expectedLayout).map {
        case (path, content) =>
          val filePath = path.split("/").foldLeft(projectRoot)(_.resolve(_))
          assertEquals(Files.readString(filePath.toNIO), content)
      }

    }

}
