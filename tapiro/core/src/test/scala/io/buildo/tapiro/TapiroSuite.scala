package io.buildo.tapiro

import java.nio.file.Files

class TapiroSuite extends munit.FunSuite {

  check(
    "http4s",
    Server.Http4s,
    "src/main/scala/schools/endpoints",
    """
      |/src/main/scala/schools/SchoolController.scala
      |package schools
      |
      |case class School(id: Long, name: String)
      |
      |sealed trait SchoolReadError
      |object SchoolReadError {
      |  case object NotFound extends SchoolReadError
      |}
      |
      |trait SchoolController[F[_], T] {
      |  @query
      |  def read(id: Long): F[Either[SchoolReadError, School]]
      |}
      |""".stripMargin,
    """
      |/src/main/scala/schools/endpoints/SchoolControllerTapirEndpoints.scala
      |//----------------------------------------------------------
      |//  This code was generated by tapiro.
      |//  Changes to this file may cause incorrect behavior
      |//  and will be lost if the code is regenerated.
      |//----------------------------------------------------------
      |
      |package endpoints
      |import schools._
      |import sttp.tapir._
      |import sttp.tapir.Codec.{JsonCodec, PlainCodec}
      |import sttp.model.StatusCode
      |
      |trait SchoolControllerTapirEndpoints[AuthToken] {
      |  val read: Endpoint[Long, SchoolReadError, School, Nothing]
      |}
      |
      |object SchoolControllerTapirEndpoints {
      |
      |  def create[AuthToken](statusCodes: String => StatusCode)(
      |      implicit codec0: JsonCodec[School],
      |      codec1: JsonCodec[SchoolReadError.NotFound.type],
      |      codec2: PlainCodec[Long]
      |  ) = new SchoolControllerTapirEndpoints[AuthToken] {
      |    override val read: Endpoint[Long, SchoolReadError, School, Nothing] =
      |      endpoint.get
      |        .in("read")
      |        .in(query[Long]("id"))
      |        .errorOut(
      |          oneOf[SchoolReadError](
      |            statusMapping(
      |              statusCodes("NotFound"),
      |              jsonBody[SchoolReadError.NotFound.type]
      |            )
      |          )
      |        )
      |        .out(jsonBody[School])
      |  }
      |}
      |
      |/src/main/scala/schools/endpoints/SchoolControllerHttpEndpoints.scala
      |//----------------------------------------------------------
      |//  This code was generated by tapiro.
      |//  Changes to this file may cause incorrect behavior
      |//  and will be lost if the code is regenerated.
      |//----------------------------------------------------------
      |
      |package endpoints
      |import schools._
      |import cats.effect._
      |import cats.implicits._
      |import cats.data.NonEmptyList
      |import org.http4s._
      |import org.http4s.server.Router
      |import sttp.tapir.server.http4s._
      |import sttp.tapir.Codec.{JsonCodec, PlainCodec}
      |import sttp.model.StatusCode
      |
      |object SchoolControllerHttpEndpoints {
      |
      |  def routes[F[_]: Sync, AuthToken](
      |      controller: SchoolController[F, AuthToken],
      |      statusCodes: String => StatusCode = _ => StatusCode.UnprocessableEntity
      |  )(
      |      implicit codec0: JsonCodec[School],
      |      codec1: JsonCodec[SchoolReadError.NotFound.type],
      |      codec2: PlainCodec[Long],
      |      cs: ContextShift[F]
      |  ): HttpRoutes[F] = {
      |    val endpoints =
      |      SchoolControllerTapirEndpoints.create[AuthToken](statusCodes)
      |    val read = endpoints.read.toRoutes(controller.read)
      |    Router("/SchoolController" -> NonEmptyList(read, List()).reduceK)
      |  }
      |}
      |""".stripMargin,
  )

  def check(
    name: String,
    server: Server,
    endpointDirectory: String,
    layout: String,
    expectedLayout: String,
    `package`: List[String] = List("endpoints"),
  )(
    implicit loc: munit.Location,
  ): Unit =
    test(name) {
      val projectRoot = FileLayout.fromString(layout)
      val tapiro = new Util()
      tapiro.createFiles(
        List(projectRoot.toString),
        List(projectRoot.toString),
        projectRoot.resolve(endpointDirectory).toString,
        `package`,
        server,
      )

      FileLayout.mapFromString(expectedLayout).map {
        case (path, content) =>
          val filePath = path.split("/").foldLeft(projectRoot)(_.resolve(_))
          assertNoDiff(Files.readString(filePath.toNIO), content)
      }

    }

}
