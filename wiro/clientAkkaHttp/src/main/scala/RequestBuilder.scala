package wiro
package client.akkaHttp

import akka.http.scaladsl.model._
import akka.http.scaladsl.model.headers.RawHeader
import java.net.URLEncoder

import io.circe._
import io.circe.generic.auto._
import io.circe.syntax._

class RequestBuilder(
  config: Config,
  ctx: RPCClientContext[_]
) {
  def build(path : Seq[String], args: Map[String, Json]): HttpRequest = {
    val completePath = path.mkString(".")
    //we're trying to match here the paths generated by two different macros
    //if it fails at runtime it means something is wrong in the implementation
    val methodMetaData = ctx.methodsMetaData
      .getOrElse(completePath, throw new Exception(s"Couldn't find metadata about method $completePath"))
    val operationName = methodMetaData.operationType.name
      .getOrElse(path.lastOption.getOrElse(throw new Exception("Couldn't find appropriate method path")))
    val uri = s"http://${config.host}:${config.port}/${ctx.path}/$operationName"

    methodMetaData.operationType match {
      case OperationType.Command(_) => commandHttpRequest(args, uri)
      case OperationType.Query(_) => queryHttpRequest(args, uri)
    }
  }

  private[this] def splitTokenArgs(args: Map[String, Json]): (List[String], Map[String, Json]) = {
    val tokenCandidates = args.map { case (_, v) => v.as[wiro.Auth] }.collect { case Right(result) => result.token }.toList
    val nonTokenArgs = args.filter { case (_, v) => v.as[wiro.Auth].isLeft }
    (tokenCandidates, nonTokenArgs)
  }

  private[this] def handlingToken(
    args: Map[String, Json]
  )(
    httpRequest: (Map[String, Json]) => HttpRequest
  ): HttpRequest = {
    val (tokenCandidates, nonTokenArgs) = splitTokenArgs(args)
    val maybeToken =
      if (tokenCandidates.length > 1) throw new Exception("Only one parameter of wiro.Auth type should be provided")
      else tokenCandidates.headOption

    maybeToken match {
      case Some(token) => httpRequest(nonTokenArgs).addHeader(RawHeader("Authorization", s"Token token=$token"))
      case None => httpRequest(nonTokenArgs)
    }
  }

  private[this] def commandHttpRequest(args: Map[String, Json], uri: String): HttpRequest =
    handlingToken(args) { nonTokenArgs =>
      HttpRequest(
        uri = uri,
        method = HttpMethods.POST,
        entity = HttpEntity(
          contentType = ContentTypes.`application/json`,
          string = nonTokenArgs.asJson.noSpaces
        )
      )
    }

  private[this] def queryHttpRequest(args: Map[String, Json], uri: String): HttpRequest =
    handlingToken(args) { nonTokenArgs =>
      val args = nonTokenArgs.map { case (name, value) => s"$name=${URLEncoder.encode(value.noSpaces)}" }.mkString("&")
      val completeUri = s"$uri?$args"
      val method = HttpMethods.GET

      HttpRequest(
        uri = completeUri,
        method = method
      )
    }
}
